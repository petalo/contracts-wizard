/**
 * @file End-to-end test for validating generated file sizes
 *
 * This test verifies that the files generated by the contracts wizard
 * have appropriate file sizes within expected ranges.
 *
 * Functions:
 * - waitForFile: Waits for a file to exist with retries
 * - validateFileSize: Validates file size is within expected range
 * - generateAndValidateFiles: Generates files and validates their sizes
 *
 * Flow:
 * 1. Generate contract files using quick template
 * 2. Wait for files to be generated
 * 3. Validate file sizes are within expected ranges
 * 4. Clean up generated files
 *
 * Error Handling:
 * - Retries file existence checks
 * - Handles missing files
 * - Validates file size ranges
 * - Cleans up on completion
 */

const path = require('path');
const fs = require('fs').promises;
const fsSync = require('fs');
const { getFileSizeKB } = require('@/utils/file-management/get-file-size');
const { exec } = require('child_process');
const { promisify } = require('util');
const { logger } = require('@/utils/common/logger');
const execAsync = promisify(exec);

// Adjust size ranges to be more flexible
const SIZE_RANGES = {
  PDF: {
    min: 300, // Reduced minimum
    max: 325, // Increased maximum
  },
  HTML: {
    min: 17, // Reduced minimum
    max: 20, // Increased maximum
  },
  MD: {
    min: 8, // Reduced minimum
    max: 10, // Increased maximum
  },
};

// File check configuration
const FILE_CHECK_CONFIG = {
  maxRetries: 30,
  retryDelay: 1000,
  writeDelay: 2000,
};

/**
 * Waits for a file to exist and be readable
 *
 * @param {string} filePath - Path to the file to check
 * @param {object} options - Options for retries
 * @returns {Promise<boolean>} - True if file exists and is readable
 */
const waitForFile = async (filePath, options = {}) => {
  const {
    maxRetries = FILE_CHECK_CONFIG.maxRetries,
    retryDelay = FILE_CHECK_CONFIG.retryDelay,
  } = options;

  for (let i = 0; i < maxRetries; i++) {
    try {
      await fs.access(filePath, fs.constants.R_OK);
      const stats = await fs.stat(filePath);
      if (stats.size > 0) {
        return true;
      }
    } catch (error) {
      // File doesn't exist or isn't readable yet
    }
    await new Promise((resolve) => setTimeout(resolve, retryDelay));
  }

  throw new Error(
    `File not found or not readable after ${maxRetries} attempts: ${filePath}`
  );
};

/**
 * Validates that a file's size is within the expected range
 *
 * @param {string} filePath - Path to the file to validate
 * @param {object} range - Min and max size in KB
 * @returns {Promise<void>}
 */
const validateFileSize = async (filePath, range) => {
  try {
    const size = await getFileSizeKB(filePath);

    if (size < range.min || size > range.max) {
      throw new Error(
        `File size ${size}KB is outside expected range (${range.min}KB - ${range.max}KB) for ${filePath}`
      );
    }

    logger.debug('File size validation successful', {
      file: path.basename(filePath),
      size,
      range,
    });
  } catch (error) {
    throw new Error(
      `Failed to validate file size for ${filePath}: ${error.message}`
    );
  }
};

/**
 * Generates contract files and validates their sizes
 *
 * @returns {Promise<void>}
 */
const generateAndValidateFiles = async () => {
  // Get project root directory
  const projectRoot = path.resolve(__dirname, '../..');

  // Ensure we're in the right directory
  process.chdir(projectRoot);

  const outputDir = path.resolve(projectRoot, 'tests/output');
  const baseName = 'quick.example';
  const templatePath = path.resolve(
    projectRoot,
    'tests/__common__/fixtures/markdown',
    `${baseName}.md`
  );
  const dataPath = path.resolve(
    projectRoot,
    'tests/__common__/fixtures/csv',
    `${baseName}.csv`
  );
  const cssPath = path.resolve(
    projectRoot,
    'tests/__common__/fixtures/css',
    `${baseName}.css`
  );

  // Verify file existence before proceeding
  for (const [type, filepath] of Object.entries({
    template: templatePath,
    data: dataPath,
    css: cssPath,
  })) {
    if (!fsSync.existsSync(filepath)) {
      throw new Error(`Required ${type} file not found: ${filepath}`);
    }
  }

  // Ensure output directory exists and is writable
  try {
    await fs.mkdir(outputDir, { recursive: true });
    await fs.access(outputDir, fs.constants.W_OK);
  } catch (error) {
    throw new Error(`Failed to prepare output directory: ${error.message}`);
  }

  // Clean any existing files
  const filesToClean = ['md', 'html', 'pdf'].map((ext) =>
    path.join(outputDir, `${baseName}.${ext}`)
  );

  for (const file of filesToClean) {
    try {
      await fs.unlink(file);
    } catch (error) {
      // Ignore errors if files don't exist
    }
  }

  try {
    // Use npx to ensure we're running the local version
    const cmd = `node bin/contracts-wizard.js generate -t "${templatePath}" -d "${dataPath}" -c "${cssPath}" -o "${outputDir}"`;
    console.log('Executing command:', cmd);

    const { stdout, stderr } = await execAsync(cmd, {
      cwd: projectRoot,
      //prettier-ignore
      env: {
        ...process.env,
        NODE_ENV: 'test'
      },
    });

    if (stderr) {
      console.error('Command stderr:', stderr);
    }
    if (stdout) {
      console.log('Command stdout:', stdout);
    }

    // Wait for write operations to complete
    await new Promise((resolve) =>
      setTimeout(resolve, FILE_CHECK_CONFIG.writeDelay)
    );

    // Define expected files with absolute paths
    const files = {
      pdf: {
        path: path.join(outputDir, `${baseName}.pdf`),
        range: SIZE_RANGES.PDF,
      },
      html: {
        path: path.join(outputDir, `${baseName}.html`),
        range: SIZE_RANGES.HTML,
      },
      md: {
        path: path.join(outputDir, `${baseName}.md`),
        range: SIZE_RANGES.MD,
      },
    };

    // Check if files exist before waiting
    for (const file of Object.values(files)) {
      const exists = await fs
        .access(file.path)
        .then(() => true)
        .catch(() => false);
    }

    // Wait for all files to exist
    await Promise.all(
      Object.values(files).map((file) => waitForFile(file.path))
    );

    // Validate sizes
    await Promise.all(
      Object.values(files).map((file) =>
        validateFileSize(file.path, file.range)
      )
    );
  } catch (error) {
    // Mejorar el mensaje de error incluyendo mÃ¡s detalles
    throw new Error(
      `File generation and validation failed: ${error.message}\n${error.stack || ''}`
    );
  }
};

describe.skip('File Size Validation', () => {

  // Skip entire test suite in CI environments
  if (process.env.CI === 'true') {
    test.skip('Skipped in CI environment', () => {
      logger.info('File size test skipped in CI environment');
    });
    return;
  }

  describe.skip('Quick Template Generation', () => {
    // Increase timeout for the entire test
    jest.setTimeout(10000);

    const paths = {
      template: 'tests/__common__/fixtures/markdown/quick.example.md',
      csv: 'tests/__common__/fixtures/csv/quick.example.csv',
      css: 'tests/__common__/fixtures/css/quick.example.css',
      output: 'tests/output',
    };

    beforeAll(() => {
      // Create output directory if it doesn't exist
      if (!fsSync.existsSync(paths.output)) {
        fsSync.mkdirSync(paths.output, { recursive: true });
      }
    });

    it('should have all required template files', () => {
      // Check if all required files exist
      ['template', 'csv', 'css'].forEach((key) => {
        const exists = fsSync.existsSync(paths[key]);
        expect(exists).toBe(true, `${key} file not found: ${paths[key]}`);
      });
    });

    it('should generate files with correct sizes', async () => {
      await generateAndValidateFiles();
    });
  });
});
